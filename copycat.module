<?php
require_once 'copycat.admin';
require_once 'copycat.config';
require 'classes/copycatXmlrpcImporter.php';
require 'classes/copycatTask.php';
require 'classes/copycatContentHandler.php';

/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */



function copycat_get_node_list($task) {
  global $settings;

  // Login to remote server    
  try {
    $task->importer->login();
  } catch (Exception $e) {
    watchdog('copycat', '@error', array('@error' => $e->getMessage()), WATCHDOG_CRITICAL);
  }


  if (true) { // Qui il controllo sul task iniziato
    /* INSERIRE QUI IL METODO PER  */
    /*
      $num_deleted = db_delete('copycat_list')
      ->condition('nid', null)
      ->execute(); */
    /* RIVEDERE IL SISTEMA cancellare i contenuti errati creati e farlo per content type */

    if ($task->isListInvalid() || $task->force_update) {
      db_truncate('copycat_import')->execute();

      try {
        $nodes = $task->importer->index($settings['source_structure']);
      } catch (Exception $e) {
        watchdog('copycat', '@error', array('@error' => $e->getMessage()), WATCHDOG_CRITICAL);
      }

      //Creates new list with the nodes to be imported.    
      try {
        $nodesInTheList = $task->createList($nodes);
        watchdog('copycat', $settings['source_structure'] . ' - Node list of ' . $nodesInTheList . ' items was successfully retrieved from parent server', array(), WATCHDOG_NOTICE);
      } catch (Exception $e) {
        watchdog('copycat', '@error', array('@error' => $e->getMessage()), WATCHDOG_CRITICAL);
      }

      if ($task->purgeOrphanNodes) {
        $numDeletedNodes = $task->purge();
        if ($numDeletedNodes > 0) {
          watchdog('copycat', '@nodes_deleted nodes no more present in the source server were deleted', array('@nodes_deleted' => $numDeletedNodes), WATCHDOG_NOTICE);
        }
      }
    }
  }

  copycat_perform_update($task);
}

function copycat_perform_update($task) {
  global $settings;
  global $force_update;

// LA query scarica i contenuti presenti in lista escludendo i giÃ  importati alla revisone massima, a meno che la variabile force_update non sia true. 
  $query = db_select('copycat_import', 'import');
  $query->leftJoin('copycat_list', 'list', 'list.uuid = import.uuid');
  $query
      ->fields('import', array('uuid', 'vid', 'nid', 'created'))
      ->fields('list', array('nid', 'uuid', 'original_vid', 'original_nid', 'changed'))
      ->range(0, $task->getSettings('nodes_for_page'))
;
  if ($task->force_update == 1) {
    $query->where('list.uuid IS null OR (list.server_id = ' . $task->importer->id . ' AND (import.created > list.changed) OR ((import.uuid = list.uuid) AND (import.vid <> list.original_vid)))');
  }
  else {
    $query->where('list.uuid IS null OR (list.server_id = ' . $task->importer->id . ' AND ((import.uuid = list.uuid) AND (import.vid <> list.original_vid)))');
  }

  $sql = (string) $query;
  $result = $query->execute();

  $number_of_rows = $result->rowCount();


  if ($number_of_rows == 0) { // Task ended, no more nodes to add
    variable_set('copycat_' . $task->importer->name . '_endtask', time());
    variable_set('copycat_' . $task->importer->name . '_force_update', 0);    
  }

  while ($record = $result->fetchAssoc()) {

    $intNid = $record['list_nid'];
    $extNid = $record['nid'];

    $uuid = $record['list_uuid'];
    $data = false;
    try {
      $data = $task->importer->node_retrieve($extNid);
    } catch (Exception $e) {
      watchdog('copycat', '@error', array('@error' => $e->getMessage()), WATCHDOG_CRITICAL);
    }

/*
    try {
      
      $query = db_insert('copycat_list')
          ->fields(array(
        'server_id' => $settings['id'],
        'server_name' => $settings['importer'],
        'nid' => 0,
        'original_nid' => $record['nid'],
        'original_vid' => $record['vid'],
        'uuid' => $record['uuid'],
        'created' => REQUEST_TIME,
        'changed' => REQUEST_TIME,
      ));
      $id = $query->execute();
    } catch (Exception $e) {
      watchdog('copycat', '@error.', array('@error' => $e->message), WATCHDOG_ERROR);
    }*/

    if (is_array($data)) {
      try{
      copycat_fill_node($data, $intNid, $task);
      }catch(Exception $e){
        
      }
    }
    else {/*

      watchdog('copycat', 'Import of node "' . $extnode['nid'] . '" failed', array(), WATCHDOG_DEBUG);
      $id = db_insert('copycat_list')
              ->fields(array(
                'server_id' => $task->importer->id,
                'server_name' => $task->importer->name,
                'nid' => 0,
                'original_nid' => $record['original_nid'],
                'original_vid' => $record['original_vid'],
                'uuid' => $record['uuid'],
                'created' => REQUEST_TIME,
                'changed' => REQUEST_TIME,
              ))->execute();*/
    }
  }
}

function copycat_cron() {
  copycat_startup();
}

function copycat_startup() {
  global $copycat_config;
  global $force_update;
  global $settings;

  $executionTime = microtime(true);
  $toProcess = Array("importer" => "", "endtask" => PHP_INT_MAX);

  foreach ($copycat_config as $key => $value) {
    // Introduce delle variabili
    $force_update = variable_get('copycat_' . $key . '_force_update', false);
    if ($force_update === false) {
      $force_update = 0;
      variable_set('copycat_' . $key . '_force_update', 0);
    }
    $purge = variable_get('copycat_' . $key . '_purge', false);
    if ($purge === false) {
      $purge = 0;
      variable_set('copycat_' . $key . '_purge', 0);
    }
    $disabled = variable_get('copycat_' . $key . '_disabled', false);
    if ($disabled === false) {
      $disabled = 0;
      variable_set('copycat_' . $key . '_disabled', 0);
    }
    // N.B: Soluzione temporanea in attesa di creare il moduilo di amministrazione


    if ($disabled == 1) {
      continue;
    }

    $endtask = variable_get("copycat_" . $key . "_endtask", 0);
    if ($endtask < $toProcess['endtask'])
      $toProcess = Array("importer" => $key, "endtask" => $endtask);
  }


  $settings = $copycat_config['' . $toProcess['importer']];

  if (empty($settings))
    return;

  variable_set('copycat_' . $toProcess['importer'] . '_endtask', -1);
  $task = new copycatTask(new copycatXmlrpcImporter($settings), $settings);
  $task->startingTime = microtime();
  if ($force_update) {
    $task->force_update = true;
  }
  if ($purge) {
    $task->purgeOrphanNodes = true;
  }

  copycat_get_node_list($task);

  $status = $task->status();

  if (empty($status)) { //Controllare se funziona ancora
    watchdog('copycat', 'The list for ' . $task->importer->name . ' is invalid. The importer will be disabled.', array(), WATCHDOG_CRITICAL);
    variable_set('copycat_' . $task->importer->name . '_disabled', 1);
    return;
  }
  if ($toProcess['endtask'] < 0) {
    watchdog('copycat', $task->importer->name . ': ' . $status['percent'] . "% - " . $status['imported'] . '/' . $status['total'] . '( ' . $status['errors'] . ' errors)  imported in ' . sprintf('%4d', ((microtime(true) - $executionTime))), array(), WATCHDOG_NOTICE);
  }
}

function copycat_fill_node($data, $nid, $task) {

  try {
    $handler = new copycatContentHandler($nid, $data, $task);
    $new_node = $handler->getNode();    
  } catch (Exception $e) {
    throw new Exception("Node " . $new_node->nid . " presents errors.".$e->getMessage());
  }

  $new_nid = 0;

  try {
    node_save($new_node);
  } catch (Exception $e) {
    $handler->errorRegister();
    watchdog('copycat', $e->getMessage(), array(), WATCHDOG_NOTICE);
    watchdog('copycat', "Node " . $new_node->title . " presents errors.", array(), WATCHDOG_NOTICE);
    unset($new_node);
    return false;
  }

  $handler->updateRegister($new_node->nid, $new_node->uuid);

  unset($new_node);

  return true;
}

/*
 * Implements hook_node_delete().
 */

function copycat_node_delete($node) {
  db_delete('copycat_list')
      ->condition('uuid', $node->uuid)
      ->execute();
}

